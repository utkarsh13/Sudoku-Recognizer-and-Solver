
import cv2
import numpy as np


# load the data we generated by sudoku_train.py
samples = np.loadtxt('training_result\sudoku-samples.data', np.float32)
responses = np.loadtxt('training_result\sudoku-responses.data', np.float32)
responses = responses.reshape((responses.size,1))

# train the KNN model
model = cv2.KNearest()
model.train(samples, responses)
    
#finding the next cell to be filled    
def findNextCellToFill(grid, i, j):
    for x in range(i,9):
        for y in range(j,9):
            if grid[x][y] == 0:
                return x,y
    for x in range(0,9):
        for y in range(0,9):
            if grid[x][y] == 0:
                return x,y
    return -1,-1

def isValid(grid, i, j, e):
    rowOk = all([e != grid[i][x] for x in range(9)])
    if rowOk:
        columnOk = all([e != grid[x][j] for x in range(9)])
        if columnOk:
            # finding the top left x,y co-ordinates of the section containing the i,j cell
            secTopX, secTopY = 3 *(i/3), 3 *(j/3)
            for x in range(secTopX, secTopX+3):
                for y in range(secTopY, secTopY+3):
                    if grid[x][y] == e:
                        return False
            return True
    return False

def solveSudoku(grid, i=0, j=0):
    i,j = findNextCellToFill(grid, i, j)
    if i == -1:
        return True
    for e in range(1,10):
        if isValid(grid,i,j,e):
            grid[i][j] = e
            if solveSudoku(grid, i, j):
                return True
            # Undo the current cell for backtracking
            grid[i][j] = 0
    return False


#putting coordinates of square in specific order--NW,NE,SE,SW
def rectify(h):
    #reshaping h from 4x1x2 to 4x2
	h = h.reshape((4,2))
    #defining array hnew of 4x2 of datatype float
	hnew = np.zeros((4,2),dtype = np.float32)

	add = h.sum(1)
	hnew[0] = h[np.argmin(add)]
	hnew[2] = h[np.argmax(add)]
	 
	diff = np.diff(h,axis = 1)
	hnew[1] = h[np.argmin(diff)]
	hnew[3] = h[np.argmax(diff)]

	return hnew
    
    
def main():  
  
    #taking input from user
    inp = raw_input("Enter Input Image Name\n")
    img = cv2.imread(inp)
    
    #converting image into grayscale
    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

    #blurring image and taking adaptive threshold of grayscale image
    blur = cv2.GaussianBlur(gray,(5,5),0)
    thresh = cv2.adaptiveThreshold(blur,255,1,1,11,2)

    #getting all contours in contours array
    contours, heirarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    #finding contour with greatest area
    biggest = None
    max_area = 0
    for i in contours:
        area = cv2.contourArea(i)
        arc = cv2.arcLength(i,True)
        approx = cv2.approxPolyDP(i, 0.02*arc, True)
        if area > max_area and len(approx) == 4:
            #biggest holds coordinates of largest square which helps us to exract sudoku square
            biggest = approx
            max_area = area

    #getting coordinates in specific order
    sq_old = rectify(biggest)

    #creating array for transformation
    sq_new = np.array([ [0,0],[359,0],[359,359],[0,359] ],np.float32)

    #transforming extracted image into an image of 360x360 
    trans = cv2.getPerspectiveTransform(sq_old,sq_new)
    new_img = cv2.warpPerspective(gray,trans,(360,360))
    cv2.imshow('Input Image',new_img)
    
    #getting the colored image back after transformation
    color_img = cv2.cvtColor(new_img,cv2.COLOR_GRAY2BGR)

    #blurring image and taking adaptive threshold of extracted image
    new_blur = cv2.GaussianBlur(new_img,(5,5),0)
    new_thresh = cv2.adaptiveThreshold(new_blur,255,1,1,11,2)
    
    #defining grid and unsolved_grid
    #grid: for final solution   unsolved_grid: for storing result from image
    grid = [[0 for row in range(0,9)] for col in range(0,9)]
    unsolved_grid = [[0 for row in range(0,9)] for col in range(0,9)]
    
    #h: height  w: width    of the small square to be selected
    h = 40
    w = 40
    sm_new = np.array([ [0,0],[39,0],[39,39],[0,39] ],np.float32)
    for i in range(0,9):
        for j in range(0,9):
            #x and y are the top left coordinates of each small square
            x = j*40
            y = i*40
            #hl:horizontal left     hr:horizontal right     vu:vertical up  vd:vertical down
            #these are the adjusted coordinatesof small square
            #this is done to remove the lineson the edges
            hl = x + 2
            hr = x + w - 3
            vu = y + 2
            vd = y + h - 3
            
            # draw the bounding box on the image
            #cv2.rectangle(img, (x, y), (x+w, y+h), (0, 0, 255), 1)
            
            #roi: region of interest
            roi = new_thresh[vu:vd, hl:hr]
            #resizing roi
            roi_small = cv2.resize(roi, (40, 40))
            #reshaping roi into 1x1600 and then making it float
            roi_small = roi_small.reshape((1,1600))
            roi_small = np.float32(roi_small)
            
            # find nearest neighbor using knn model
            retval, results, neigh_resp, dists = model.find_nearest(roi_small, k =5)
            
            #storing result
            string = str(int((results[0][0])))
            
            grid[i][j] = int(results[0][0])
            unsolved_grid[i][j] = int(results[0][0])
            
    
    #solving sudoku
    solveSudoku(grid)
    
    # write the result the output image
    for i in range(0,9):
        for j in range(0,9):
            if unsolved_grid[i][j] == 0:
                x = j*40
                y = i*40
                hl = x + 2
                hr = x + w - 3
                vu = y + 2
                vd = y + h - 3
                string = str(grid[i][j])
                cv2.putText(color_img, string, (hl+6, vd-6), 0, 1, (255, 0, 0),2)
    
    #displaying output image
    cv2.imshow('Output Image',color_img)
    
    #saving image
    cv2.imwrite('result_' + inp,color_img)
    cv2.waitKey(0)


if __name__ == '__main__' :
	main()